# {{ .Domain }} (managed by NGM)

{{- /* Reusable HTTPS server body (shared by TCP 443 and QUIC 443 servers) */ -}}
{{- define "https_common" -}}
    server_name {{ .Domain }};

    ssl_certificate     {{ .TLSCert }};
    ssl_certificate_key {{ .TLSKey }};

    ssl_protocols TLSv1.3;
    ssl_early_data on;

    access_log {{ .AccessLog }};
    error_log  {{ .ErrorLog }};

    root {{ .Webroot }};
    index index.php index.html index.htm;

    # Always expose cache status for debugging (fastcgi/proxy)
    add_header X-Cache-Status $upstream_cache_status always;

    # If upstream emits absolute http:// links (common when WP thinks it is HTTP),
    # tell browsers to upgrade them to https:// to avoid mixed-content blocks.
    # This mimics what many WAFs do.
    add_header Content-Security-Policy "upgrade-insecure-requests" always;

    {{- if eq .Mode "php" }}

    {{- if .FrontController }}
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }
    {{- else }}
    location / {
        try_files $uri $uri/ =404;
    }
    {{- end }}

    location ~ \.php$ {
        include fastcgi_params;
        fastcgi_pass {{ .PHP.Pass }};
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;

        {{- if .PHP.Cache.Enabled }}
        # FastCGI cache (zone defined globally via fastcgi_cache_path)
        set $skip_cache 0;
        if ($request_method !~ ^(GET|HEAD)$) { set $skip_cache 1; }
        if ($http_authorization != "") { set $skip_cache 1; }
        if ($http_cookie ~* "(wordpress_logged_in|PHPSESSID|session|token)") { set $skip_cache 1; }
        if ($request_uri ~* "(wp-admin|wp-login\.php|cart|checkout|my-account)") { set $skip_cache 1; }

        fastcgi_cache {{ .PHP.Cache.Zone }};
        fastcgi_cache_valid 200 {{ .PHP.Cache.TTL200 }};
        fastcgi_cache_use_stale error timeout updating;
        fastcgi_cache_lock on;
        fastcgi_cache_bypass $skip_cache;
        fastcgi_no_cache $skip_cache;
        {{- end }}
    }

    {{- else if eq .Mode "proxy" }}

    # Static assets cache (long TTL)
    location ~* \.(?:css|js|mjs|map|jpg|jpeg|png|gif|webp|svg|ico|woff2?|ttf|eot|mp4|webm|pdf|zip)$ {
        proxy_http_version 1.1;
        # Allow upstream keepalive: strip hop-by-hop Connection header from client.
        # (Nginx will manage keepalive to the upstream pool.)
        proxy_set_header Connection "";

        {{- if .Proxy.PassHost }}
        proxy_set_header Host $host;
        {{- else }}
        proxy_set_header Host $http_host;
        {{- end }}

        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Host  $host;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Port  443;
        proxy_set_header X-Forwarded-Ssl   on;
        proxy_redirect off;

        proxy_connect_timeout {{ .Proxy.TimeConnect }};
        proxy_read_timeout    {{ .Proxy.TimeRead }};
        proxy_send_timeout    {{ .Proxy.TimeSend }};

        {{- if .Proxy.StaticCache.Enabled }}
        proxy_cache {{ .Proxy.StaticCache.Zone }};
        proxy_cache_valid 200 301 302 {{ .Proxy.StaticCache.TTL200 }};
        proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
        proxy_cache_lock on;

        # Donâ€™t let upstream cookies poison asset cache
        proxy_ignore_headers Set-Cookie;
        proxy_hide_header Set-Cookie;

        expires {{ .Proxy.StaticCache.TTL200 }};
        add_header Cache-Control "public" always;
        {{- end }}

        # If upstream sets cookies on assets (rare), force them to be HTTPS-safe.
        # (Harmless if no cookies are set.)
        proxy_cookie_path / "/; Secure; SameSite=Lax";

        proxy_pass http://up_{{ .UpstreamKey }};
    }

    location / {
        proxy_http_version 1.1;
        # Allow upstream keepalive: strip hop-by-hop Connection header from client.
        # WebSocket case below will override this.
        proxy_set_header Connection "";

        {{- if .Proxy.PassHost }}
        proxy_set_header Host $host;
        {{- else }}
        proxy_set_header Host $http_host;
        {{- end }}

        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Host  $host;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Port  443;
        proxy_set_header X-Forwarded-Ssl   on;
        proxy_redirect off;

        {{- if .Proxy.Websockets }}
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        {{- end }}

        # Make upstream cookies HTTPS-safe behind the reverse proxy.
        proxy_cookie_path / "/; Secure; HttpOnly; SameSite=Lax";

        proxy_connect_timeout {{ .Proxy.TimeConnect }};
        proxy_read_timeout    {{ .Proxy.TimeRead }};
        proxy_send_timeout    {{ .Proxy.TimeSend }};

        {{- if .Proxy.Microcache.Enabled }}
        # Proxy microcache (zone defined globally via proxy_cache_path)
        set $skip_cache 0;
        if ($request_method !~ ^(GET|HEAD)$) { set $skip_cache 1; }
        if ($http_authorization != "") { set $skip_cache 1; }
        if ($http_cookie ~* "(wordpress_logged_in|PHPSESSID|session|token)") { set $skip_cache 1; }
        if ($request_uri ~* "(wp-admin|wp-login\.php|cart|checkout|my-account)") { set $skip_cache 1; }

        proxy_cache {{ .Proxy.Microcache.Zone }};
        proxy_cache_valid 200 {{ .Proxy.Microcache.TTL200 }};
        proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
        proxy_cache_lock on;
        proxy_cache_background_update on;
        proxy_cache_revalidate on;
        proxy_cache_bypass $skip_cache;
        proxy_no_cache $skip_cache;
        {{- end }}

        proxy_pass http://up_{{ .UpstreamKey }};
    }

    {{- else }}

    # static
    location / {
        try_files $uri $uri/ =404;
    }

    {{- end }}
{{- end -}}

{{- if eq .Mode "proxy" }}

upstream up_{{ .UpstreamKey }} {
    {{- if eq .Proxy.LB "least_conn" }}
    least_conn;
    {{- end }}
    {{- range .Proxy.Targets }}
    {{- if .Enabled }}
    server {{ .Addr }}{{ if gt .Weight 0 }} weight={{ .Weight }}{{ end }}{{ if .Backup }} backup{{ end }};
    {{- end }}
    {{- end }}
    keepalive 32;
}
{{- end }}

# HTTP -> HTTPS + ACME challenge
server {
    listen 80;
    server_name {{ .Domain }};

    access_log {{ .AccessLog }};
    error_log  {{ .ErrorLog }};

    location ^~ /.well-known/acme-challenge/ {
        root {{ .ACMEWebroot }};
        default_type "text/plain";
        allow all;
    }

    location / {
        return 301 https://$host$request_uri;
    }
}

# HTTPS (TCP 443)
server {
    listen 443 ssl;

    {{- if .EnableHTTP3 }}
    # Advertise HTTP/3 to clients that connect over TCP first
    add_header Alt-Svc 'h3=":443"; ma=86400' always;
    {{- end }}

    http2 on;

{{ template "https_common" . }}
}

{{- if .EnableHTTP3 }}

# HTTPS (UDP 443 - HTTP/3)
server {
    listen 443 quic reuseport;

    http3 on;

{{ template "https_common" . }}
}

{{- end }}
